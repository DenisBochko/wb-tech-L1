package main

import "fmt"

func setBit(num int64, i uint8, bit uint8) int64 {
	if bit != 0 {
		// Тут базовое ИЛИ.
		// Если нужно установить i-тый бит в 1, то мы просто логически складываем само num
		// И бит, который нам нужно преобразовать из 0 в 1, получаем результат.
		return num | (1 << i)
	}

	// Здесь ситуация сложнее, но похожая
	// В выражении z = x &^ y каждый бит z равен 0, если соответствующий бит y равен 1.
	// Если бит в y равен 0, то берется значение соответствующего бита из x.
	// Получается, что мы сохраняем все значения num (x), кроме одного, которое мы сдвинули во втором операнде (y),
	// Оно как раз таки инвертируется.
	return num &^ (1 << i)
}

func main() {
	var n int64 = 5 // двоично: 0101
	fmt.Println("Исходное:", n)

	// Установить 1-й бит в 0 (получается 0-ой, т.к. нумерация с 0)
	res1 := setBit(n, 0, 0)
	fmt.Printf("Установить 1-й бит в 0: %d. Двоичное представление: %08b\n", res1, res1)

	// Установить 4-й бит в 1
	res2 := setBit(n, 3, 1)
	fmt.Printf("Установить 3-й бит в 1: %d. Двоичное представление: %08b\n", res2, res2)
}
